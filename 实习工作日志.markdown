# 工作日志

### 六月11日 周二
1. 申请公司内网（找mac地址；注册国内邮箱 tanhao7633@163.com），装tfs系统 ✅
2. 发送照片申请门卡 ✅
3. 跟川波老师meeting，规划实习任务和计划（审批系统开发）✅
4. 其他注意事项：不要迟到（早上8点半-9点，晚上5点半-6点），带丝徽穿正装，午休11点半-1点 ✅

**知识点：**
- 工具：Postman, DBeaver, PostgreSQL
- tomcat：web-application container；Restful request；F5: load balance & fault tolerence; 
- Redis，像RAM一样快，但是又不会一关机就丢失。将所有数据保存在内存中，因而读写操作非常快速。虽然数据存储在内存中，但Redis也支持数据持久化，将数据定期保存到磁盘（快照备份），以防数据丢失。
- message queue（消息中间件，作用是削峰填谷）: 1. kafka 2. RabbitMQ 3, RocketMQ
- xxlJob：定时任务
- 瀑布式开发：需求 - 设计 - 开发 - 测试 - 验收
- 敏捷开发agile development

#### 公司的社交媒体服务平台，后端的微服务microservice有: sjmt, smdp, smsp, agent.
1) sjmt （社交媒体缩写）：基础服务类  提供对接公众号、小程序、企业微信、抖音的基础服务
包括接收回调消息
2) smsp（也是中文缩写）：业务类服务,小程序端、企业微信H5等
3) smdp：针对社媒配置平台的服务，纯内网服务
4) agent：前台应用层，将接口转调到sjmt、smsp服务
之后我要写的审批内容主要在smdp里面。


### 六月12日 周三
1. 公司内账号已激活，等待安装“小绿点”网络安全保护。✅
2. 通过telnet + ip地址的形式去查是否有墙，联系安全部门开墙。✅
3. 开测试系统权限，开通理赔合作伙伴这个测试专用企微账号 ✅
4. 连接DBeaver远程数据库，等待开墙⌛️
5. IDEA配置（SDK 1.8，最稳定）✅


### 六月13日 周四
1. DBeaver墙已开，但连接显示“服务器不支援SSL连线”，问题待解决 ⌛️
2. IDE里代码显示“Could not autowired. No beans of 'xxx' type found”报错，这其实是因为老版Intellij不能识别Spring Boot的annotation导致的，在不修改代码的情况下，从内网下载了较新版本的Intellij 2022 community edition，报错问题已解决。✅
3. 跟天成和李龙泰老师了解了审批程序的结构：使用的是双向链表，在分叉节点点击添加节点会一次添加三个节点（审批条件、审批人、抄送人）。我之后会负责新增一个审批模版导出功能。✅
4. 听川波老师开会，学习了一些管理学上的经验，例如：当一个周五due的任务被分配给组员时，应该提前在周二周三就询问对方是否有把握在周五做好，而不是周四周五再去催。

**小Tip：**
1. 网页上按F12，通过查看Network和Console来获知前端传回了什么信息。
2. 在IntelliJ里双击shift可以全局搜索。
3. 输入list.for可以快速生成遍历。


### Java项目里常见的功能模块：
1. api是接口层，文件夹里面有各种控制器Controller，接前端传回的请求，将请求发给service业务逻辑层处理。
2. service是业务逻辑层，是后端的核心，连接controller和dao。
3. dao层(Data Access Object)负责操作数据库，里面定义了对数据表的CRUD操作。我们现在这个Spring project里用的是MyBatis的Mapper接口来跑SQL操作数据库。
4. po是presistent object，与数据库结构一一对应，用ORM（如JPA、Hibernate）进行数据映射。po一般通过数据库事务来操作，确保数据的一致性和完整性。
5. vo是value object，是可以读取的值，用于在不同层之间传递数据。vo不需要与数据库结构严格对应，可以根据业务需求灵活定义。

### 数据库事务(Database Transaction)
项目里可以看到如下代码，这些其实就是数据库事务操作指令。

TransactionStatus ts = DbTransaction.begin();（**开始事务**）
DbTransaction.commit(ts);（**提交事务**）
DbTransaction.rollBack(ts);（**回滚事务**：一般放在try-catch的catch exception里，事务有失败的操作就全部回滚）

数据库事务具有以下四个重要属性（**ACID**）：
1. **Atomicity 原子性**：一个transaction里的操作要么全部成功，要么全部失败。其中一个失败，全部已经执行了的操作都要回滚（rollback）到事务开始前的状态。
2. **Consistency 一致性**：transaction在执行之前和执行之后，数据库的状态必须一致，都要保证合法。
3. **Isolation 隔离性**：在一个事务未提交之前，其他事务不能看到其中间状态。不同事务之间的操作互不干扰，仿佛他们是按照顺序执行的。
4. **Durability 持久性**：一但一个事务提交成功了，它改变的数据就会永久保存在数据库中，及时系统崩溃也不会丢失。


### 六月14日 周五
1. 上午在参加2024德勤数字化挑战赛决赛 ✅
2. 回家后记得自己装一下mac上的telnet ⌛️
3. D解决Beaver“服务器不支援SSL连线”的问题。是因为需要更换一个驱动。✅
4. 写工作周报 ✅
5. 写新入职电脑配置指南 ✅



### 六月17日 周一
1. 开始写导出模块的代码，学习怎么用apache的XSSFWorkbook库来把数据导出成Excel ✅
2. 实际上手了用PostMan来测试端口，学会了怎么用PostMan debug（cURL，body）✅
3. 企业微信没法传输图片和文件，待解决 ⌛️
4. 回家后记得自己装一下mac上的telnet ⌛️
5. 导出模块已经可以成功下载成Excel文件了，还存在bug需要修 ✅


导出Excel可参考：src/main/java/com/picc/smdp/report/api/ActivationReport23Api.java

XSSFWorkbook和HSSFWorkbook的区别：
**`HSSFWorkbook`**：用于操作 Excel 97-2003 文件（.xls 格式）。
**`XSSFWorkbook`**：用于操作 Excel 2007 及以上版本文件（.xlsx 格式）。

**导出模块的业务逻辑：**
**后端**：使用 `XSSFWorkbook` 创建 Excel 文件，并将其转换为 Base64 编码的字符串返回给前端。
*注意：不能只导出当前页面的，所有满足条件的工单都需要导出。*
**前端**：发送请求到后端获取 Base64 编码的 Excel 文件字符串，将其转换为可下载的文件，并触发下载。

cURL = command URL



```html
<template>
  <div>
    <button @click="downloadExcel">导出工单历史记录</button>
  </div>
</template>

<script>
import axios from 'axios';

export default {
  name: 'ExportButton',
  methods: {
    async downloadExcel() {
      try {
	// 发送请求到后端获取Base64编码的Excel文件字符串
        const response = await axios.post('/ManagementService/exportWorkFormList', {
          corpid: 'yourCorpid',
          work_id: 'yourWorkId',
          template_name: 'yourTemplateName',
          work_status: 'yourWorkStatus',
          pageindex: 1,
          pagesize: 100
        }, {
          headers: {
            'Content-Type': 'application/json'
          }
        });
        // 获取后端传回的Base64编码的Excel文件字符串
        const base64Data = response.data.data;
        // 创建一个隐藏的link，用于触发文件下载
        const link = document.createElement('a');
        // 将Base64的Excel字符串转换为提供文件下载的data URL
        link.href = 'data:application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;base64,' + base64Data;
        // 设置下载文件的名称
        link.download = 'file_name.xlsx';
        // 触发下载操作
        link.click();
      } catch (error) {
        console.error('导出失败', error);
      }
    }
  }
};
</script>
```